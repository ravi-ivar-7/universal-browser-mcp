/**
 * @fileoverview ExecutionKernel Interface Definition
 * @description Defines the core execution engine interface for Record-Replay V3
 */

import type { JsonObject } from '../../domain/json';
import type { FlowId, NodeId, RunId } from '../../domain/ids';
import type { RRError } from '../../domain/errors';
import type { FlowV3 } from '../../domain/flow';
import type { DebuggerCommand, DebuggerState } from '../../domain/debug';
import type { RunEvent, RunStatus, Unsubscribe } from '../../domain/events';

/**
 * Run Start Request
 */
export interface RunStartRequest {
  /** Run ID (generated by caller) */
  runId: RunId;
  /** Flow ID */
  flowId: FlowId;
  /** Flow Snapshot (full Flow definition used during execution) */
  flowSnapshot: FlowV3;
  /** Running Parameters */
  args?: JsonObject;
  /** Start Node ID (defaults to Flow's entryNodeId) */
  startNodeId?: NodeId;
  /** Tab ID (must be assigned by caller, exclusive per Run) */
  tabId: number;
  /** Debug Configuration */
  debug?: { breakpoints?: NodeId[]; pauseOnStart?: boolean };
}

/**
 * Run Execution Result
 */
export interface RunResult {
  /** Run ID */
  runId: RunId;
  /** Final Status */
  status: Extract<RunStatus, 'succeeded' | 'failed' | 'canceled'>;
  /** Total Duration (ms) */
  tookMs: number;
  /** Error Information (if failed) */
  error?: RRError;
  /** Output Results */
  outputs?: JsonObject;
}

/**
 * Run Status Info
 */
export interface RunStatusInfo {
  /** Current Status */
  status: RunStatus;
  /** Current Node ID */
  currentNodeId?: NodeId;
  /** Start Time */
  startedAt?: number;
  /** Last Updated Time */
  updatedAt: number;
  /** Tab ID */
  tabId?: number;
}

/**
 * ExecutionKernel Interface
 * @description Core execution engine for Record-Replay V3
 */
export interface ExecutionKernel {
  /**
   * Subscribe to event stream
   * @param listener Event listener
   * @returns Unsubscribe function
   */
  onEvent(listener: (event: RunEvent) => void): Unsubscribe;

  /**
   * Start Run
   * @description Add Run to queue and start execution
   */
  startRun(req: RunStartRequest): Promise<void>;

  /**
   * Pause Run
   * @param runId Run ID
   * @param reason Pause reason
   */
  pauseRun(runId: RunId, reason?: { kind: 'command' }): Promise<void>;

  /**
   * Resume Run
   * @param runId Run ID
   */
  resumeRun(runId: RunId): Promise<void>;

  /**
   * Cancel Run
   * @param runId Run ID
   * @param reason Cancel reason
   */
  cancelRun(runId: RunId, reason?: string): Promise<void>;

  /**
   * Execute Debugger Command
   * @param runId Run ID
   * @param cmd Debugger command
   */
  debug(
    runId: RunId,
    cmd: DebuggerCommand,
  ): Promise<{ ok: true; state?: DebuggerState } | { ok: false; error: string }>;

  /**
   * Get Run Status
   * @param runId Run ID
   * @returns Run status info or null (if not found)
   */
  getRunStatus(runId: RunId): Promise<RunStatusInfo | null>;

  /**
   * Recover execution
   * @description Called after Service Worker restart to recover interrupted Runs
   */
  recover(): Promise<void>;
}

/**
 * Create NotImplemented ExecutionKernel
 * @description Phase 0 Placeholder Implementation
 */
export function createNotImplementedKernel(): ExecutionKernel {
  const notImplemented = () => {
    throw new Error('ExecutionKernel not implemented');
  };

  return {
    onEvent: () => {
      notImplemented();
      return () => { };
    },
    startRun: async () => notImplemented(),
    pauseRun: async () => notImplemented(),
    resumeRun: async () => notImplemented(),
    cancelRun: async () => notImplemented(),
    debug: async () => notImplemented(),
    getRunStatus: async () => notImplemented(),
    recover: async () => notImplemented(),
  };
}
